<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EventRepository.kt</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">agent-data-api</a> &gt; <a href="index.source.html" class="el_package">com.xdraiv.agentdata.events</a> &gt; <span class="el_source">EventRepository.kt</span></div><h1>EventRepository.kt</h1><pre class="source lang-java linenums">package com.xdraiv.agentdata.events

import com.jillesvangurp.ktsearch.*
import com.jillesvangurp.searchdsls.querydsl.*
import com.xdraiv.agentdata.alertLogs.PaginatedResponse
import com.xdraiv.agentdata.config.AppConfig
import io.ktor.client.*
import io.ktor.client.engine.cio.*
import kotlinx.serialization.json.Json
import org.springframework.stereotype.Repository
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeParseException

@Repository
<span class="fc" id="L16">class EventRepository(private val config: AppConfig) {</span>

<span class="fc" id="L18">    private val httpClient = HttpClient(CIO) {}</span>

<span class="fc" id="L20">    private val client = SearchClient(</span>
<span class="fc" id="L21">        KtorRestClient(</span>
<span class="fc" id="L22">            https = false,</span>
<span class="fc" id="L23">            nodes = arrayOf(</span>
<span class="fc" id="L24">                Node(</span>
<span class="fc" id="L25">                    config.agentData.host,</span>
<span class="fc" id="L26">                    config.agentData.port</span>
                )
            ),
<span class="fc" id="L29">            client = httpClient</span>
        )
    )

    fun parseDate(dateString: String): ZonedDateTime? {
<span class="nc" id="L34">        val formats = listOf(</span>
<span class="nc" id="L35">            DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd'T'HH:mm:ss.SSSXXX&quot;),</span>
<span class="nc" id="L36">            DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd'T'HH:mm:ss.SSSZ&quot;)</span>
        )
<span class="nc" id="L38">        return formats.asSequence().mapNotNull { format -&gt;</span>
<span class="nc" id="L39">            try {</span>
<span class="nc" id="L40">                ZonedDateTime.parse(dateString, format)</span>
<span class="nc" id="L41">            } catch (e: DateTimeParseException) {</span>
<span class="nc" id="L42">                null</span>
<span class="nc" id="L43">            }</span>
<span class="nc" id="L44">        }.firstOrNull()</span>
    }

    fun toIso8601Format(dateTime: String): String {
<span class="nc bnc" id="L48" title="All 4 branches missed.">        return parseDate(dateTime)?.format(DateTimeFormatter.ISO_INSTANT) ?: dateTime</span>
    }

<span class="fc" id="L51">    private val json = Json {</span>
<span class="fc" id="L52">        ignoreUnknownKeys = true</span>
<span class="fc" id="L53">    }</span>

<span class="nc" id="L55">    suspend fun searchEvents(</span>
        page: Int,
        size: Int,
        fields: List&lt;String&gt;?,
        values: List&lt;String&gt;?,
<span class="nc" id="L60">        operations: List&lt;String&gt;? = listOf(&quot;equals&quot;),</span>
<span class="nc" id="L61">        startTime: String? = null,</span>
<span class="nc" id="L62">        endTime: String? = null,</span>
        location: String?,
        indexName: String?
    ): PaginatedResponse&lt;Event&gt; {

        // Perform the search query
<span class="nc" id="L68">        val response = client.search(indexName) {</span>
<span class="nc" id="L69">            resultSize = size</span>
<span class="nc" id="L70">            from = (page - 1) * size</span>
<span class="nc" id="L71">            query = bool {</span>
<span class="nc" id="L72">                must(matchAll())</span>

<span class="nc bnc" id="L74" title="All 2 branches missed.">                fields?.forEachIndexed { index, field -&gt;</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">                    val value = values?.get(index)</span>
<span class="nc bnc" id="L76" title="All 4 branches missed.">                    val operation = operations?.getOrNull(index) ?: &quot;equals&quot;</span>
<span class="nc bnc" id="L77" title="All 4 branches missed.">                    when (operation) {</span>
<span class="nc" id="L78">                        &quot;equals&quot; -&gt; must(term(field, value!!))</span>
<span class="nc" id="L79">                        &quot;gte&quot; -&gt; must(range(field) { gte = value!! })</span>
<span class="nc" id="L80">                        &quot;lte&quot; -&gt; must(range(field) { lte = value!! })</span>
<span class="nc" id="L81">                        else -&gt; must(term(field, value!!))</span>
                    }
<span class="nc" id="L83">                }</span>

                // Apply the time range filter to the nested content.id.time field
<span class="nc bnc" id="L86" title="All 4 branches missed.">                if (startTime != null &amp;&amp; endTime != null) {</span>
<span class="nc" id="L87">                    must(nested {</span>
<span class="nc" id="L88">                        path = &quot;content&quot;</span>
<span class="nc" id="L89">                        query = range(&quot;content.id.time&quot;) {</span>
<span class="nc" id="L90">                            gte = toIso8601Format(startTime)</span>
<span class="nc" id="L91">                            lte = toIso8601Format(endTime)</span>
<span class="nc" id="L92">                        }</span>
<span class="nc" id="L93">                    })</span>
                }
<span class="nc" id="L95">            }</span>
<span class="nc" id="L96">            sort {</span>
<span class="nc" id="L97">                add(&quot;content.id.time&quot;, SortOrder.DESC) // Adjust sort to nested field</span>
<span class="nc" id="L98">            }</span>
<span class="nc" id="L99">        }</span>

        // Calculate total items and total pages
<span class="nc" id="L102">        val totalItems = response.total</span>
<span class="nc" id="L103">        val totalPages =</span>
<span class="nc bnc" id="L104" title="All 4 branches missed.">            if (totalItems == 0L) 1 else (totalItems / size).toInt() + if (totalItems % size == 0L) 0 else 1</span>

        // Deserialize hits to Event objects
<span class="nc bnc" id="L107" title="All 4 branches missed.">        val items = response.hits?.hits?.map { json.decodeFromString&lt;Event&gt;(it.source.toString()) } ?: emptyList()</span>

<span class="nc" id="L109">        return PaginatedResponse(</span>
<span class="nc" id="L110">            items = items,</span>
<span class="nc" id="L111">            totalItems = totalItems,</span>
<span class="nc" id="L112">            totalPages = totalPages,</span>
<span class="nc" id="L113">            currentPage = page</span>
        )
    }

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>